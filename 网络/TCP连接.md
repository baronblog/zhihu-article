### TCP 协议入门一(连接和释放)

<br/>

#### 连接的过程
* TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫客户端，被动等待连接建立的一方叫服务器

<br/>

* 初始状态，两端都处于CLOSED的状态，然后服务器打开了TCP服务，进入LISTEN状态，监听特定的端口，等待客户端TCP请求

<br/>

##### 第一次握手
* 客户端主动打开连接，发送TCP报文，进行第一次握手，然后进入SYN_SEND状态，等待服务器发送确认报文
* 首部的同步位SYN为1(为1就表明这是一个请求连接报文)， 会初始化一个序号Sequence Number=0(第一次的话一般是0，从0开始传数据，wireshark一般为0，实际上是随机初始化一个序列号，防止被黑客猜到序列号)，并且会把发送方的MSS值(Max Segment Size最大数据分段，在options字段里面)

<br/>

##### 第二次握手
* 服务器接到了SYN报文，如果同意连接，则向客户端发送一个确认报文，且会把服务器上的MSS值发送给接收方，进行协商，取最小值，然后服务器进入SYN_RECD状态

<br/>

* 此时首部的SYN仍然为1，ACK在之前序号的基础上上加1， 同时为自己初始化一个序列号Seq为K
* 这个报文同样不携带数据

<br/>

##### 第三次握手
* 客户端收到了服务器发过来的确认报文，还需要向服务器给出确认信息，然后进入establish状态
* 此时首部SYN不再为1，而ACK为1，确认号ACK number=K+1， 序号为之前的Number+1

###### 为什么TCP要三次握手，而不是两次，不是四次
* 三次本质上是为了验证客户端-服务器双方通讯功能正常：
    * 第一次握手：验证客户端发送功能ok，验证服务器接收功能ok
    * 第二次握手： 验证服务器发送功能ok，验证客户端接收功能ok
    * 第三次：让服务器知道客户端接收功能ok

#### TCP 四次挥手
##### 第一次挥手
* 客户端向服务器发送结束报文，然后进入**FIN_WAIT_1**状态，其中报文里面FIN=1,SEQ=M

##### 第二次挥手
* 服务端收到客户端的结束报文，进入**FIN_WAIT_2**然后发送确认报文，服务器端进入**CLOSE_WAIT**状态，此时报文段FIN=1，SEQ=M+1，ack=M+1

##### 第三次挥手
* 前面几次挥手只关闭了客户端往服务端发送数据的通道，但是服务器往客户端发数据的通道仍然存在，所以在这一步骤之前还可以往客户端发送数据
* 数据处理完毕后，发送确认信息，ack=M+1，FIN=1,SEQ=N,然后服务器进入**LAST_ACK**状态

##### 第四次挥手
* 客户端收到服务端的结束报文，然后发送确认报文，进入**TIME_WAIT**状态，然后经过2MSL之后，自动进入CLOSE状态


#### 疑问
* 为什么在两次握手的时候，第一次握手发送方是1460字节(window size为64240)，接收方是1440字节(window size为29200)，第三次window size是517字节，这个数据确定的过程是怎么样的？

* TCP包头很复杂，需要重点关注5个问题：顺序问题，丢包问题，连接维护，流量控制，拥塞控制，分别是用什么机制来控制的？
    * 顺序问题 && 丢包问题：使用序列号加确认机制来包装，每次发送都会带有序号，由TCP进行重组，如果超过一定时间没有收到确认号，会触发超时重传机制
    * 连接维护：使用三次连接和四次挥手来保证收发双发的收发能力正常，如果没有发送信息，使用心跳机制来进行断开连接
    * 流量控制：
    * 拥塞控制：

* TCP有这么多的连接状态，如何查看某个连接的状态？
    * 使用netstat -nat|grep -i "80"可以查看连接状态
    * 使用lsof -i:80端口查看连接状态

* 学会了TCP你能干什么？或者说解决了什么问题？这是和我一起工作的大佬同事提出来的
    * 学了TCP我能更好地理解socket，而socket是很多源码的基石
    * 学习了TCP能更好地理解网络里面一些很经典的套路，比如说IO多路复用里面的select，poll，epoll模型
